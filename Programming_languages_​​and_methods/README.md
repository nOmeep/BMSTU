# Лекция №1. Понятие объекта и инкапсуляции
***
## Основные понятия

<u>**Определения:**</u>

1. <font color=green>**Объект</font>(`Object`)** - самоописывающая структура данных, обладающая внутренним состоянем, способная обрабатывать передаваемые ей сообщения.

2. <font color=green>**Инкапсуляция**</font> - доступ к внутреннему состоянию объекта осуществляется извне (_через механизм передачи сообщений_).

3. <font color=green>**Класс</font>(`class`)**: 
    - тип данных, значениями которого являются объекты, имеющие сходные внутренние состояния и обрабатывающие одинаковый набор сообщений.
    - шаблон объекта, обладающего какими-либо свойствами.

<u>**Замечание**</u>: класс можно рассматривать как шаблон для порождения объектов -> объект - экземпляр класса.

## Классы в Java

<u>**Виды классов в Java по доступу</u>:**
- Публичные(`public`)
- Непубличные(например, `private`)

<u>**Утверждение**</u>: любой java-файл должен содержать ровно 1 `public` класс, имя файла должно совпадать с именем класса!

```Java
//Name.java:

    public class Name 
    {
        //... // описание класса, объявляются члены класса
    }
```

<u>**Замечание**</u>: непубличные классы видны только в пределах этого файла(не `private` доступны также внутри пакета)!

## Члены класса

- <font color=green>**Экземплярные поля</font>:** для хранения внутреннего состояния объекта.
```Java
class Point
{
    double x; // поле x
    double y; // поле y
    //...
}
```
- <font color=green>**Экземплярные методы</font>:** отвечают за обработку передаваемых объекту сообщений.
- <font color=green>**Статические поля</font>:** хранение данных, общих для всех объетов класса.
- <font color=green>**Статические методы</font>:** имеют доступ только к статическим полям, оперируют только с данными, общими для всех объектов класса.
- <font color=green>**Вложенные классы</font>:** объекты, необходимые для реализации данного класса.
- <font color=green>**Статический конструктор</font>:** набор `static` блоков, инициализация статических полей.

<u>Определение</u>: 
- <font color=green>**Статическое поле</font>(static field)** - поле, разделяемое всеми объектами этого класса.

<u>*Пример объявления статического поля*</u>:
```Java
class Point 
{
    public int x, y; // координаты конкретной точки
    public static int count; // количество точек системы
}
```
<u>**Определение**</u>: 
- <font color=green>**Экземплярный метод**</font> - подпрограмма, осуществляющая обработку переданного объекту сообщения. Экземплярный метод **передает объекту сообщение**. Экземплярный метод **имеет доступ к внутреннему состоянию объекта** засчет передачи в экземплярном методе ссылки на сам объект. В Java эта ссылка имеет имя `this`.

<u>**Определение**</u>:
- <font color=green>**Экземплярное поле**</font> - именованная составляющая, составная часть внутреннего состояния объекта.

<u>**Замечание**</u>: некоторые ООП ЯП допускают прямое обращение к экземплярным полям, что нарушает инкапсуляцию.

## Модификаторы доступа

<u>*Пример использования модификаторов*</u>:
```Java
class Person
{
    public String name;
    public int yearOfBirth;
    private String address; 
}
// private и public - модификаторы доступа
```
<u>**Замечание**</u>: Модификаторы доступа предназначены для управления доступом к членам классов.

<u>**Наименование модификатора**</u>:
- `private`. Доступен самому себе
- `public`. Доступен всем и везде :-)
- `protected`. Доступен внутри пакета, самому себе и наследникам
-  `без модификатора`. Доступен внутри пакета

## Перегрузка методов

<u>**Определение**</u>: 
- <font color=green>**Сигнатура метода**</font> - информация о количестве и формальных параметрах метода.

<u>*Пример перегрузки метода*</u>:

```Java
public class Cat 
{
    public String name;
    public int age;
    public int weight;
    public Cat(String name, int age, int weight)
    {
        this.name = name;
        this.age = age;
        this.weight = weight;
    }
    // перегружаем путем создания одноименного конструктора с другой сигнатурой
    public Cat() {
        //...
    }
}
```

<u>**Определение**</u>: 
- <font color=green>**Перегрузка метода**</font>(overload) - объявление для одного и того же класса двух или более методов, имеющих одно и то же имя, но разные сигнатуры.

***
# Лекция №2. Статические поля, методы, блоки
***
потом допишу
***
# Лекция №3. Наследование и субтипизация. Переопределение методов.
***
потом допишу
***
# Лекция №4. Перегрузка. Абстрактные методы и интерфейсы.
***
потом допишу
***
# Лекция №5.
***
## Конейнерные классы

<u>**Определение**</u>: 
- <font color=green>**Контейнерный класс**</font> - это класс, объекты которого выступают в роли хранилищ других объектов.

<u>*Пример*</u>:
- **java.util.ArrayList**
- **java.util.Queue**

<u>**Замечание**</u>: контейнерные классы --> обобщенные классы(с java 15)

<u>*Пример необобщенного класса Stack*</u>:

```Java
import java.util.Arrays;
public class Stack {
    // этот пример был ранее
    //...
}
```
<u>*Использование необощенного класса Stack*</u>:

```Java
//...
Stack s = new Stack();
s.push(1); // (*)
s.push(2); // (*)
s.push(3); // (*)
int sum = 0;
while(!s.empty()) {
    int x = (Integer)s.pop(); // Integer - обертка // (**) 
    s += x; // cумма элементов в стеке
}
//...
```
<u>**Замечание1**</u>: "Обертки изучить самостоятельно" Посевин.

<u>**Замечание2**</u>: Методичку с++ начать изучать самостоятельно, будет проверка :)

<u>**Замечание3**</u>: Метод `push()` требует `Object`, мы передаем целое число `int` в качестве параметра, в результате происходит автоматическое **заворачивание** целого числа (`int`) в объект стандартного класса `Integer`. Присвоение объекта класса `Integer` переменной `x` означает его автоматическое **разворачивание**

<u>**Замечание4**</u>: в Java есть синтаксический сахар, который присутствует в строчках кода (*) и (**) без которого пришлось бы писать следующим образом:

```Java
// ...
s.push(1); --> s.push(new Integer(1));
s.push(2); --> s.push(new Integer(2));
// ...  
int x = (Integer)(s.pop()).intValue();
```
### Основные проблемы при использовании необобщенных контейнерных классов
*Перепишем код предыдущей программы:*
```Java
Stack s = new Stack(); // попробуем засунуть double
// на этапе компиляции ошибки не будет
s.push(1);
s.push(2);
s.push(3.14); // опа постирония :)

int sum = 0;
while (!s.empty()) {
    int x = (Integer)s.pop();
    sum += x;
}

// Результат работы "java.lang.Double cannot be cast to java.langInteger"
```

<u>**Замечание**</u>: Т.к. мы передаем 3.14 в контейнер, в котором числа по логике программы должны быть целые числа.

<u>**Замечание**</u>: Мы не получаем никаких сообщений при компиляции, однако программа "свалилась" во время выполнения.

<u>**Решение приведенной проблемы**</u>: 

- **использование обобщенных классов**.

### Понятие обобщенного класса

<u>**Определения**</u>: 

- <font color=green>**Обобщенный класс**</font> - это класс, имеющий **формальные типовые параметры**.

- <font color=green>**Формальные типовые параметры**</font> - это тип, который используется в объявлении обобщенного класса и при этом неизвестен во время компиляции обобщенного класса.

<u>*Пример объявления обобщенного класса*</u>:

```Java
class ClassName<param1, param2, ..., paramN>
```

<u>*Пример*</u>:

```Java
class Map<K, N>;
//параметры принято задавать в верхнем регистре
```

<u>*Пример</u>(Обобщенный класс `Stack`)*:

```Java
import java.util.Arrays();

public class Stack<T> {
    private int count = 0;
    private Object[] buf = new Object[30];
    public boolean empty() { return count == 0; }
    public void push(T x) { // параметр обощаем, класс не зависим от него
        if (count == buf.lenght) {
            buf = Arrays.CopyOf(buf, buf.lenght * 2);
        }
        buf[count++] = x;
    }
    public T pop() {
        if (empty()) {
            throw new RuntimeExeption("emptySatck");
        }
        return (T)buf[--count];
    }
}
```

<u>*Пример использования обобщенного класса</u> `Stack`*:

```Java
// <Integer> - фактические типовые параметры //
Stack<Integer> s = new Stack<Integer>();
s.push(1);
s.push(2);
s.push(3);
int sum = 0;
while(!s.empty()) {
    int x = s.pop();
    sum += x;
}
```

`<Integer>` - фактические типовые параметры.

<u>**ВАЖНОЕ ЗАМЕЧАНИЕ**</u>: При попытке добавить число 3.14 в Stack на этапе компиляции получим сообщение об ошибке.

```Java
"method push in class Stack<T> cannot be applied to given types"
```

<u>**Замечание**</u>: Другим преимуществом класса `Stack` является то, что теперь метод `pop()` возвращает `Integer`, а не `Object`. При инициализации переменной `х` отпадает необходимость явного приведения типа.

### Ограниченные обобщенные классы

<u>**Определение**</u>: 
- <font color=green>**Ограниченный обобщенный класс**</font> - это обобщенный класс, хотя бы для одного формального типового параметра которого задана **верхняя граница**.

<u>**Утверждение**</u>: Говорят, что для формального типового параметра задана его верхняя граница, если базовый класс для типового параметра - НЕ `Object`.

Другими словами, такому типовому параметру разрешено сопоставлять не любой класс, а некоторый класс `X` или любого наследника `Х`.
```Java
class Имя<..., параметр extends X, ...>
```
<u>**Замечание**</u>: Задание верхней границы типового параметра класса `Х` позволяет вызывать методы класса `Х` из тела обобщенного класса.

<u>*Пример*</u>:

```Java
public class Stack<T extends Number> {
    private int count = 0;
    private Number[] buf = new Number[30];
    // ...
    // ... тут все методы empty() push() pop() без изменений (см. выше)
    // ...
    public T max() {
        if (empty()) {
            throw new RuntimeExeption("empty");
        }
        Number max = buf[0];
        for (int i = 1; i < count; i++) {
            Number x = buf[i];
            if (x.doubleVale() > max.doubleValue()) {
                max = x;
            }
        }
        return max;
    }
}
```

<u>*Пример использования обобщенного ограниченного класса Stack</u>*:

```Java
Stack<Integer> s = new Stack<Integer>();

s.push(1);
s.push(2);
s.push(3);
System.out.println(s.max());
```

<u>**Замечание**</u>: В реализации класса Stack мы объявляем поле `buf` как массив `Number`ов, но компилятор проследит, чтобы фактические параметры (`T extends Number`) класса Stack выступали только наследники класса `Number`.

<u>*Пример*</u>:(Параметризуем класс `Stack` классом `String`)

```Java
Stack<String> s = new Stack<String>();
//...
```

***
# Лекция №6.
***
## Ковариантность массивов
_**Утверждение**: в Java массивы ковариантны. Если класс `S` является наследником класса `T`, то тип `S` является подтипом `T`._

В частности ковариантность массивов позволяет написать следующее:

```Java
Integer[] ints = new Integer[10];
Numbers[] numbers = ints;
```

*Пример:* что будет после попытки присвоить `numbers` ссылки на объект, тип которого не `Integer`:
```Java 
numbers [0] = 3.14;
```
*Результат:(при компиляции ошибки не произойдет в силу ковариантности, но во время исполнения программа аварийно завершится с исключением)*
```Java
"java.lang.ArrayStoreExeption"
```
*Утверждение: Если бы удалось положить ссылку `Double` в `numbers`, то эта ссылка бы очутилась в массиве `int`, в котором должны храниться только ссылки на `Integer`.*

## Инвариантность обобщенных классов 

*Пример: с классом `Stack` в обобщенном варианте*
```Java
Stack<Integer> ints = new Stack<Integer>();
Stack<Numbers> = ints
// выше делали похожую операцию 
// ошибка возникнет на этапе компиляции, а не на этапе исполнения
```
*Результат:*
```Java
error: incompatible types
Stack<Number> numbers = ints;
                        ^
```
*Комментарий:*
- Это происходит, потому что обобщенные классы в Java **инвариантны**!

Т.е. если `G` - обобщенный класс, класс `S` - наследник класса `T`, то классы `G<S>` и `G<T>` отношением наследования не связаны.

*Комментарий:*
- Если обобщенный класс `DerivedStack<T>` - наследник `Stack<T>`, то `DerivedStack<Integer>` - наследник `Stack<Integer>`

## Шаблоны обобщенных классов 

_**Замечание:** Инваринатность обобщенных классов, на первый взгляд, ограничивает возможность полиморфной обработки объектов этих классов. Например, наивно написанный метод для вывода содержимого стека `Number`'ов будет непригоден для вывода стеков `Integer`'ов_
```Java
public static void printStack(Stack<Number> stack) {
    while (!stack.empty()) {
        Number x = stack.pop();
        System.out.println(x);
    }
}
```
Указанный выше метод непригоден для `Integer`. Для обхода подобного будем делать следующее.

**Определение:** Шаблон обобщенного класса `G` - это неявный супертип(более глобальный тип данных) для любого класса, поражденного из `G`. Шаблон получается параметризацией класса `G` специальным символом `?`. Например `Stack<?>`.

## Особеенности шаблонов 

1. **Можно** объявлять переменную типа "шаблон", но **невозможно** создать его объект.

    *Пример:*
    ```Java
    // Так можно
    Stack<?> x; // correct

    // Так нельзя
    x = new Stack<?> // error fuck u leatherman
    ```
    _**Замечание:** В данном случае мы над переменной понимаем не только локальные переменные, но и формальные параметры методов, поля, элементы массивов._

    *Пример: массив с элементами типа "шаблон"*
    ```Java
    Stack<?>[] a = new Stack<?>[10];
    ```

2. Если тип переменной - шаблон некоторого обобщенного класса `G`, то этой переменной можно присвоить ссылку на любой объект класса `G`, независимо от того, какой фактический типовой параметр был передан классу `G` при создании объекта.

    ```Java
    x = new Stack<Integer>;
    x = new Stack<Float>;
    ```
    *Пример:* полимофизм на основе шаблонов.
    ```Java
    public class Test {
        public static void printStack(Stack<?> stack) {// теперь используем обобщенный шаблон, раньше был Numbers, а стал "?"
            while (!stack.empty()) {
                Number x = stack.pop();
                System.out.println(x);
            }
        }
    }
    
    //  магия перехода... 

    public static void main(String[] args) {
        Stack<Integer> s = new Stack<Integer>();
        s.push(1);
        s.push(2);
        s.push(3);
        printStack(s);
    }
    ```
    _**Замечание**: Метод pop шаблона `Stack<?>` возвращает Number - верхняя граница формального типового параметра обобщенного класса `Stack` (см. предыдущую лекцию)_

## Частичные шаблоны 

_**Утверждение:** Если обобщенный класс имеет несколько формальных типовых параметров, то возможно получить **частичный шаблон**, передав классу `?` вместо части фактических типовых параметров_

```Java
Map<Integer, ?> intMap;
// Правильно 
intMap = new Map<Integer, String>(); // correct

// Это тоже пойдет
intMap = new Map<Integer, Float>(); // corret

// А за такое suck some dick
intMap = new Map<Double, String>(); // ERROR!
```

Последнее присваивание вызовет ошибку компиляции, потому что первый фактический параметр обобщенного класса `Map` не `?` и даже не `Double`, а `Integer`!

## Шаблоны, ограниченные сверху
Как было показано в примере о методе `pop()` шаблон `Stack<?>`, фактический параметр `?` имеет верхнюю границу, по умолчанию совпадает с верхней границей соответвующего формального параметра обобщенного класса.

*Пример*: Верхней границей `?` в `Stack<?>` является `Number`, поэтому `pop()` для `Stack<?>` возвращает `Number`.

_**Замечание**: Верхнюю границу в шаблоне `?` можно уточнить так:_
```Java
G<..., ? extends X, ...>
```
_**Замечание**: Уточнение верхней границы сузит количество подтипов шаблона:_
```Java
Stack<Float> floats = new Stack<Float>();
Stack<?> numbers = floats;
Stack<? extends Integer> ints = floats; // ERROR! 
```
***
# Лекция №7.
***
## Понятие полиморфизма в программировании
**Определение:**

1. <font color=green>**Полиморфизм**</font> - это способность функций и методов обрабатывать данные **разных типов**. 
2. <font color=green>**Полиморфизм**</font> заключается в том, что **один и тот же фрагмет** кода может работать **с разными типами данных**.

**Пример на Си**:
```C
#include <stdio.h>

int sum(int a, int b)
{
    return a+b
}

void main(void) {
    int x, y;
    x = 1;
    y = 2;
    z = sum(x, y);
}
```
Формальными параметрами функции `sum(int a, int b)` выше могут выступат только `int`, так как в Си статическая типизация.

## Особенности шаблонов обощенных классов

1. Шаблоны можно объявлять следующм образом
```Java
Stack<?> x; //ok
x = new Stack<?> // not ok ERROR 
```
2. Еще пример объявления шаблона
```Java
x = new Stack<Integer>();
x = new Stack<Float>(); 
```

*Вид обобщенного класса `Stack`*(был еще лекции 2 назад):
```Java
import java.util.Arrays();

public class Stack<T> {
    private int count = 0;
    private Object[] buf = new Object[30];
    public boolean empty() { return count == 0; }
    public void push(T x) { // параметр обощаем, класс не зависим от него
        if (count == buf.lenght) {
            buf = Arrays.CopyOf(buf, buf.lenght * 2);
        }
        buf[count++] = x;
    }
    public T pop() {
        if (empty()) {
            throw new RuntimeExeption("emptySatck");
        }
        return (T)buf[--count];
    }
}
```

*Утверждение:* У шаблона, ограниченного сверху, недоступны методы, тип параметров которых соответствует `?` в шаблоне. Например, у шаблона `Stack<?>` не доступен метод `push()`:
```Java
Stack<? extends Integer> number = new Stack<Integer>();
number.push(10); // работать не будет 
```
**ПОЯСНЕНИЕ:** Переменнная `numbers` может содержать ссылку на `Stack<Float>` (см. 1) и тогда передача `push()` целого числа может оказаться некоректной.

**Замечание:** Применительно к контейнерным обобщенным классам можно сказать, что использование шаблонов не позволяет написать полиморфный метод, осуществляющий запись новых значений в объект контейнерного класса.

## Шаблоны, ограниченные снизу

<u>**Утверждение**</u>: Шаблоны можно так же ограничивать снизу.
```Java
G<..., ? super X, ...>
```
<u>**Утверждение**</u>: Подтипом такого шаблона будут все полученные из `G` класса, у которых в качестве соответсвующего фактического типового параметра выступает `X` или любой суперкласс `Х`.

```Java
Stack<? super Integer>();
ints = new Stack<Number>();
ints = new Stack<Float>();
```

<u>**Утверждение**:</u> У ограниченного снизу шаблона контейнерного класса можно вызвать методы для записи значений того класса, которым он ограничен.

<u>**Пример**:</u>
```Java
Stack<? super Integer> ints = new Stack<Number>();
ints.push(10) // ok, но pop() вызвать мы не сможем
```

## Методы, недоступные у шаблонов, ограниченных снизу

<u>**Утверждение**:</u> У шаблона, ограниченного снизу, **не доступны методы, тип возвращаемого значения которых соответствует шаблону**, например, у шаблона `Stack<?>` не доступен метод `pop()`:
```Java
Stack<? super Integer> ints = new Stack<Integer>();
ints.push(10);
int x = ints.pop(); // не будет работать
```

<u>**ПОЯСНЕНИЕ**</u>: Переменная `ints` может содержать ссылку на `Stack<Numbers>` и тогда метод `pop()` может возвратить, например, `Float`! 

<u>**Замечание**:</u> Применительно к контейнерным классам, можно сказать, что **использование их шаблонов, ограниченных снизу не позволяет написать полиморфный метод, осуществляющий чтение значений из объекта контейнерного класса**.

<u>*Пример*:</u>
```Java
Producer extends and customer super // шок
```

<u>**Утверждение:**</u> Так как одним из наследников класса `Number` является класс `BigInteger`, представляющий числа произвольной разрядности, в отличие от `Integer`, класс `BigInteger` может иметь наследников.

<u>**Задача**:</u> Напишем метод, который переписывает элементы стека `BigInteger`'ов в стек `BigInteger`'ов `Number`'ов.

```Java
public static void pushReversed(
    Stack<? super BigInteger> dest, 
    Stack<? extends BigInteger> src) {
        while(!src.empty()) {
            dest.push(src.pop());
        }
    }
```

<u>**Замечание**:</u> Данный метод реализовывает принцип **PECS**: `src`(Producer) поставляет значения и ограничивается сверху, `dest`(Customer) принимает значения и ограничивается снизу.

<u>**Замечание по типовым параметрам у методов**:</u>
- Метод `pushReversed()` из предыдущего примера плох тем, что ориентируется на списки `BigInteger`. Он полиморфен в том смысле, что в качестве параметра `src` ему можно передать список объектов производного от `BigInteger` класса, а в качестве `dest` - список объектов базового для `BigInteger` класса.

<u>**Замечание**:</u> В Java методы могут иметь типовые параметры, тогда `pushReversed` будет иметь вид:
```Java
public static <T extends Number> void pushReversed(
    Stack<? super T> dest, Stack<? extends T> src) {
        while(!src.empty()) {
            dest.push(src.pop());
        }
    }
```

## Объявление и вызов обобщенного метода

<u>**Определение**:</u> 
- <font color=green>Обобщенный метод</font> - это статический или экземплярный метод класса, имеющий формальные типовые параметры.

<u>**Замечание**:</u> В объявлении метода типовые параметры непосредственно предшествут типу возвращаемого значения метода.

<u>**Вызов статического обобщенного метода запишем следующим образом**:</u>
```Java
имя_класса<фактич.типовые параметры> имя_метода(...)
```
<u>**Вызов экземплярного обобщенного метода запишем следующим образом**:</u>
```Java
объект<факт.типовые параметры> имя_метода(...)
```

## Нештатные ситуации

<u>**Определение:**</u>

- <font color=green>Нештатная ситуация</font> - это ситуация, в которых выполнение некоторого фрагмента программы оказывается по тем или иным причинам невозможно.

<u>**Определение:**</u>

- <font color=green>Исключительная ситуация</font> - это нештатная ситуация, возникающая в силу некоторых внешних факторов. Например, не открылся файл, ошибка в доступе к данным, разрыв сетевого соединения.

<u>**Определение:**</u>

- <font color=green>Ошибочная ситуация</font> - это нештатная ситуация, возникшая в результате ошибки в коде программы. Например, переполнение стека, выход за границы массива...

## Перехват нештатных ситуаций 

<u>**Определение:**</u>

- <font color=green>Перехват нештатных ситуаций</font> - это механизм, обеспечивающий продолжение работы программы при возникновении нештатных ситуаций.

<u>**Два механизма перехвата нештатных ситуаций**</u>:

1. <font color=green>**Обработка кодов возврата**</font> - функция, во время выполнения которой может возникнуть нештатная ситуация, возвращает некоторое значение(код ответа), которое говорит о том, успешно ли функция отработала. **Перехват ситуаций** заключается в проверке кода ответа этой функции.
1. <font color=green>**Обработка исключений**</font> - в данном случае производится исключение, которое описывает данную внештатную ситуацию. **Генерация исключений приводит к передаче управления на фрагмент кода программы, который называется <font color=green>обработчиком исключений</font>

## Иерархия классов исключений

<u>**Определение:**</u>

- <font color=green>Исключение в Java</font> - это объект, который описывает нештатную ситуацию 

```
тут должна быть схемка посевна, но все и так очевидно  :)
что я просто записал ее ниже текстом
```
- <font color=lightgreen>Throwable</font> - базовый класс для любых классов исключений
- <font color=lightgreen>Error</font> - базовый класс, описывающий критические или "смертельные" для программы системные ошибочные ситуации.
- <font color=lightgreen>Exeption</font> - базовый класс для всех несистемных исключений
- <font color=lightgreen>RuntimeExeption</font> - базовый класс для классов несистемных исключений, описывающих ошибочные ситуации. **Ситуации, возникающие из-за ошибок в коде программы**.

***
# Лекция №8
***

Пример 

```Java
public class SomeExeption extends Exeption {
    public SomeExepion(){
        super("Some exeption");
    }
}
```

Expeption и RuntimeExeption наиболее популярные классы для создания своих исключений 

<u>**Замечание**</u>: В качестве базового класса для создания своих собственных классов обработки исключительных ситуаций можно выбрать Throwable, Exeption, RuntimeExeption, Error или любой другой класс, являющийся подклассом класса Throwable. 

<u>**Замечание**</u>: Как правило, при создании собственного класса обработки исключительных ситуаций наследуют от классов Exeption или RuntimeExeption в зависимости от того, какие нештатные ситуации необходимо описать.

<u>**Важное замечание**</u>: В силу особенностей реализации обобщенных классов в Java, классы исключений не могут быть обобщенными!

## Неперехваченные исключения

<u>**Пример программы деления на ноль**</u>:

```Java
public class Test {
    public static void main(String[] args) {
        System.out.println(100/0); // порождение неперехваченной
        //искючительной ситуации, приводящей к завершению программы 
    }
}
```

<u>**Результат запуска программы выше**</u>:
```Java
Exeption in thread "main" 
java.langArithmeticExeption . /by zero at Test.main(Test.java: 6)
```

## Операторы перехвата исключений

<u>**Синтаксис перехвата исключений**</u>:

- `try`-блок
```Java
try {
    //* код, в котором может возникнуть нештатная ситуация 
    // ...
}
```
- `catch`-блок

```Java
try {
    //* код, в котором может возникнуть нештатная ситуация 
    // ...
}
catch (SomeExeption e) { // catch-блок
    // обработка исключений, которые можно привести к типу SomeExeption
    // какой-то код обработки
}
catch (SomeExeption2 e) { 
    // ...
}
// ... другие кеч-блоки
```
- `finally`-блок
```Java
try {
    //* код, в котором может возникнуть нештатная ситуация 
    // ...
}
catch (SomeExeption e) { // catch-блок
    // обработка исключений, которые можно привести к типу SomeExeption
    // какой-то код обработки
}
catch (SomeExeption2 e) { 
    // ...
}
// ... другие кеч-блоки
finally {
    // код, который выполнится при любом выходе из try-блоков
}
```


<u>**Пример программы с перехватом исключения**</u>:

```Java
public class Test {
    public void main(String[] args) {
        try {
            System.out.println(1000/0); // пытаемся сделать постиронию
        } catch (ArithmeticExeption e) { // встроенная в станд. библиотеку Java-класс обработки искл. ситуаций с арифметическими операциями 
            Systme.out.println(e.getMessage()); // /by zero 
        } finally {
            System.out.println("end of program");
        }
    }
}
```

<u>**Результат запуска программы выше**</u>:

```
Exeption in thread "main" 
/by zero at
exit from try 
end of program 
```

<u>**Примеры классов исключений**</u>:

1. FileNotFoundExeption - файл не найден
1. ArithmeticExeption - исключительная ситуация при выполнении математической операции
1. ArrayIndexOfBoundsExeption - выход за пределы массива

<u>**Замечание**</u>: В Java таких классов много! kekw

## Порождение исключений

Ранее использовали класс Stack, в этом класса был определен метод pop():
```Java
public Object pop() {
    if(empty()) {
        trow new RuntimeExeption("underflow"); // обработка исключения
    }
    return buf[--count];
}
```

<u>**Утверждение**</u>: Порождение исключения выполняется оператором throw.

<u>**Замечание**</u>: Если собственный класс обработки исключения не является подклассом класса Error или RuntimeExeption, то для любого поражденного исключения в коде программы должен быть предусмотрен обработчик. 

```Java
Тип m(параметры) throws x, y, z
{
    //... Если в процессе выполнения некоторого метода m 
    // могут порождаться исключения x, y, z и эти исключения в теле метода
    // не перехватываются, то объявление метода должно выглядеть так(выше)
} 
```

<u>**Пример неправильного порождения исключения**</u>:

```Java
public class X {
    void z() {
        throw new SomeExeption();
    }
}
```

<u>**Будет генерироваться следующее исключение**</u>:

```
x.java:5 error: unreported exeption SomeExeption;
    must be caught or declarated to be thrown
        throw new SomeExeption();
```

<u>**Пример правильного порождения исключения**</u>:

```Java
public class X {
    void z() throws SomeExeption {
        throw new SomeExeption();
    }
}
```

## Понятие функтора

<u>**Определение**</u>:

- <font color=green>Функтор</font> - это обобщенный класс, параметризованный типом T и инкапсулирующий значение/значения типа T, удовлетворяющий следующим условиям:
    
    - Объекты функтора неизменяемые!
    - У функтора имеется метод map, получающий в качестве параметра функцию(т.е. лямбда-выражение) преобразования значения типа T 
    - Метод map применяет функцию к значению/значениям, лежащему/лежащим внутри функтора. Возвращает новый объект, в котором инкапсулирован/инкапсулированы результат/результаты применения функции
    - Если передать методу map функцию, которая просто возвращает значение своего аргумента, то единственным эффектом вызова метода map будет порождение объекта функтора, идентичного исходному объекту.

<u>**Пример функтора Roots, который инкапсулирует представление корней какого-то уровнения**</u>:

```Java
public class Roots<T> {
 private HashSet<T> container;
 private Roots(HashSet<T> container) {
     this.container = container;
 }
 // ... 
}
```

T - тип одного корня, при этом мы не делаем никакого предположения об этом типе.

Конструктор функтора Roots является приватным, так объекты функторы будут порождаться лишь методами, решающими уравнения, либо методами map

<u>**Порождение объектора функтора Roots через решение уравнения**</u>:

```Java 
public class Roots<T> {
    //...
    public static Roots<Double> of(double a, double b, double c) {
        HashSet<Double> roots = new HashSet<>;
        if (a == 0.0) {
            if (b != 0) {
                roots.add(-c/b);
            } else {
                double d = b * b - 4 * a * c;
                if (d >= 0.0) {
                    roots.add((-b + Math.sqrt(d))/ (2 * a));
                    roots.add((-b - Math.sqrt(d))/ (2 * a));
                }
            }
            return new Roots<>(roots);
        }
    }
}
```
***
# Лекция №8
***

**ПРОДОЛЖЕНИЕ ПРОШЛОЙ ЛЕКЦИИ:**

## Реализация метода map в функторе `Roots`

<u>**Утверждение**</u>: Метод `map` применяет функцию f к корням, лежамщим в объекте функтора.

<u>**Пример**</u>:

```Java
public class Roots<T> {
    ...
    
    public <R> Roots<R> map(Function<T, R> f{
        HashSet<R> c = new HashSet<>();
        
        for (T t : container) c.add(f.apply(t));
        
        return new Root<c> // корни уравнения, см. пример прошлой лекции
    }) // фунциональный интерфейс из стандартной библиотеки JAVA
} 
```

<u>**Утверждение**</u>: Функциональный интерфейс Functional входит в стандартную библиотеку Java и определеятся следующим образом:

```Java
public interface Function<T, R> {
    R apply(T t);

    ...
}
```

## Перебор корней в функторе `Roots`

Обеспечим доступ к корням через метод `forEach`, который применяет не возврящающую значение функцию ко всем корням: 

```Java
public class Roots<T> {
    public void forEach(Consumer<T> f) { // Consumer(функц. интерфейс)тоже из стандартной библиотеки Java
        for (T t : container) f.accept(t);
    }

    ...
}
```

<u>**Утверждение**</u>: Функциональный интерфейс `Consumer` из стандартной библиотеки Java определятся следующим образом:

```Java
public interface Consumer<T> {
    void accept(T, t); // передаем параметр  корни

    ...
}
```

<u>**ЗАДАЧА**</u>:

- Рассмотрим задачу о камне, брошенном с поверхности Земли со скоростью `V` под углом `fi` к горизонту. На каком расстоянии от точки бросания камень достигнет высоты `h`?

```
График из классичекой задачи по физике с камнем, брошенным под углом к горизонту. Оси координат, график и отмеченные значения :)
```

<u>**РЕШЕНИЕ**</u>:

Рассмотрим вспомогательный класс `Point` 

```Java
public class Point {
    private double x;
    private double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double dist() {
        return Math.sqrt(x * x + y * y);
    }

    @Override
    public String toString() {
        return String.format("(%f %f)", x, y);
    }
}
```

## Пример использования функтора `Roots`

Для решения задачи необходимо решить уравнения:

- (g * t^2 / 2) + (v * t * sin(fi)) - h = 0

приведем решение в методе `main` класса `Stone`:

```Java
public class Stone {
    private static final double G = 9.81;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        double v = sc.nextDouble();
        double fi = sc.nextDouble() * Math.PI / 180;
        double h = sc.nextDouble();

        Roots.of(-1 - G/2, v * Math.sin(fi), -1 * h).map(t -> new Point(t * Math.cos(fi), h)).map(pt -> pt.dist()).forEach(x -> System.out.println(x)); // см. прошлую лекцию. Выполняет метод of функтора Roots, который порождает объект функтора путем решения квадратного уравнения;       
    }
}
```

## Введение в монады на примере функтора `Roots`

<u>**ЗАДАЧА**</u>:

- Используем функтор `Roots` для хранения корней уравнения 4й степени вида:
    
    - f(fi(x)) = a * (x^2 + p * x) + b * (x^2 + p * x) + c = 0;
    
    где fi(x):
    
    - fi(x) = y = x^2 + p * x;

Данная задача решается в два этапа, на первом этапе мы решаем уравнения y = x ^ 2 + p * x <=> x^2 + p * x - y = 0;

Запишем фрагмент программы решающей данные уравнения. Имеет вид:

```Java
Roots<Roots<Double>> roots = Roots.of(a, b, c).map(y -> Roots.of(1.0, p, -1.0 * y))
```

Очевидно, что уравнение (*) имеет до 4х корней типа `double`, которые было бы удобно хранить в объекте типа Roots<Double>, а не в конструкции вида Roots<Roots<Double>>

<u>**Данная проблема решается с помощью монады**</u>, когда функтор `Roots` превращается в монаду путем добавления метода `flatMap`. 

```Java
public class Roots<T> {
    ...

    public <R> Roots<R> flatMap(
        Function<T, Roots<R>> f) {
            HashSet<R> c = new HashSet<>();

            map(f).forEach(rs -> c.addAll(rc.container));

            return new Roots<>(c); // (*)
        }

        ...
}
```

<u>**Комментарий к 1053 строке (*)**</u>: Метод `flatMap` объединяет множества корней из небольших объектов класса `Roots` в одно множество.

## Пример использования метода `flatMap`

<u>**Утвержение**</u>: Теперь, используя монады,(`flatMap`) мы можем сразу получить все корни нашего уравнения (см. (*)) 4й степени в виде Roots<Double>:

```Java
Roots<Double> roots = Roots.of(a, b, c).flatMap(y -> Roots.of(10, p, -1 * y));
```

## Некоторые ВЫВОДЫ касаемо монад

- Функторы и монады предназначены для лаконичной записи последовательностей преобразования данных

- Лаконичность записи достигается путем сокрытием громоздких управляющих конструкций языка Java(операторов выбора и циклов) внутри методов функторов и монад

- Так как функторы и монады, а также их методы являются обобщенными, в процессе преобразования может меняться тип данных.

<u>**Определение монады**</u>:

- <font color=green>Монада</font> - это функтор с дополнительным методом `flatMap`, удовлетворяющим следующим условиям:

    - Метод `flatMap` получает в качестве параметра функциюб способную преобразовать каждое значение внутри монады и завернуть результат преобразования в новый объект монады. 

    - Метод `flatMap` применяет функцию f ко всем ко всем значениям, хранящимся внтури монады и объединяет получившийся объект монады в один объект

    - Метод `flatMap` ассоциативен, т.е m.`flatMap(f).flatMap(g)` эквивалентен `m.flatMap(x -> f(x).flatMap(g))` 








