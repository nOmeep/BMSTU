# Лекция №1. Понятие объекта и инкапсуляции
***
## Основные понятия

**Объект(`Object`)** - самоописывающая структура данных, обладающая внутренним состоянем, способная обрабатывать передаваемые ей сообщения.

**Инкапсуляция** - доступ к внутреннему состоянию объекта осуществляется извне (_через механизм передачи сообщений_).

**Класс(`class`)**: 
- тип данных, значениями которого являются объекты, имеющие сходные внутренние состояния и обрабатывающие одинаковый набор сообщений.
- шаблон объекта, обладающего какими-либо свойствами.

_Замечание: класс можно рассматривать как шаблон для порождения объектов -> объект - экземпляр класса._

## Классы в Java

**Классы в Java:**
- Публичные(`public`)
- Непубличные(например, `private`)

_Утверждение: любой java-файл должен содержать ровно 1 `public` класс, имя файла должно совпадать с именем класса!_

```Java
//Name.java:

    public class Name 
    {
        //... // описание класса, объявляются члены класса
    }
```

_Замечание: непубличные классы видны только в пределах этого файла(не `private` доступны также внутри пакета)!_

## Члены класса

- **Экземплярные поля:** для хранения внутреннего состояния объекта.
```Java
class Point
{
    double x; // поле x
    double y; // поле y
    //...
}
```
- **Экземплярные методы:** отвечают за обработку передаваемых объекту сообщений.
- **Статические поля:** хранение данных, общих для всех объетов класса.
- **Статические методы:** имеют доступ только к статическим полям, оперируют только с данными, общими для всех объектов класса.
- **Вложенные классы:** объекты, необходимые для реализации данного класса.
- **Статический конструктор:** набор `static` блоков, инициализация статических полей.

_Определение: **Статическое поле(static field)** - поле, разделяемое всеми объектами этого класса._

*Пример объявления статического поля:*
```Java
class Point 
{
    public int x, y; // координаты конкретной точки
    public static int count; // количество точек системы
}
```
_Определение: **Экземплярный метод** - подпрограмма, осуществляющая обработку переданного объекту сообщения. Экземплярный метод передает объекту сообщение._
- экземплярный метод имеет доступ к внутреннему состоянию объекта засчет передачи в экземплярном методе ссылки на сам объект. В Java эта ссылка имеет имя `this`.

_Определение: **Экземплярное поле** - именованная составляющая, составная часть внутреннего состояния объекта._

_Замечание: некоторые ООП ЯП допускают прямое обращение к экземплярным полям, что нарушает инкапсуляцию._

## Модификаторы доступа

*Пример использования модификаторов:*
```Java
class Person
{
    public String name;
    public int yearOfBirth;
    private String address; 
}
// private и public - модификаторы доступа
```
_Замечание: Модификаторы доступа предназначены для управления доступом к членам классов._

**Наименование модификатора:**
- `private`. Доступен самому себе
- `public`. Доступен всем и везде :-)
- `protected`. Доступен внутри пакета, самому себе и наследникам
-  *без модификатора*. Доступен внутри пакета

## Перегрузка методов

_Определение: **Сигнатура метода** - информация о количестве и формальных параметрах метода._

*Пример перегрузки метода:*
```Java
public class Cat 
{
    public String name;
    public int age;
    public int weight;
    public Cat(String name, int age, int weight)
    {
        this.name = name;
        this.age = age;
        this.weight = weight;
    }
    // перегружаем путем создания одноименного конструктора с другой сигнатурой
    public Cat() {
        //...
    }
}
```

_Определение: **Перегрузка метода(overload)** - объявление для одного и того же класса двух или более методов, имеющих одно и то же имя, но разные сигнатуры._
***
# Лекция №2. Статические поля, методы, блоки
***
потом допишу
***
# Лекция №3. Наследование и субтипизация. Переопределение методов.
***
потом допишу
***
# Лекция №4. Перегрузка. Абстрактные методы и интерфейсы.
***
потом допишу
***
# Лекция №5.
***
## Конейнерные классы

_Определение: **Контейнерный класс** - это класс, объекты которого выступают в роли хранилищ других объектов_

*Пример:*
- java.util.ArrayList
- java.util.Queue

_Замечание: контейнерные классы --> обобщенные классы(с java 15)_

*Пример необобщенного класса Stack:*
```Java
import java.util.Arrays;
public class Stack {
    // этот пример был ранее
    //...
}
```
*Использование необощенного класса Stack:*
```Java
//...
Stack s = new Stack();
s.push(1); // (*)
s.push(2); // (*)
s.push(3); // (*)
int sum = 0;
while(!s.empty()) {
    int x = (Integer)s.pop(); // Integer - обертка // (**) 
    s += x; // cумма элементов в стеке
}
//...
```
_**Замечание1**: "Обертки изучить самостоятельно" Посевин._

_**Замечание2**: Методичку с++ начать изучать самостоятельно, будет проверка :)_

_**Замечание3**: Метод `push()` требует `Object`, мы передаем целое число `int` в качестве параметра, в результате происходит автоматическое **заворачивание** целого числа (`int`) в объект стандартного класса `Integer`. Присвоение объекта класса `Integer` переменной `x` означает его автоматическое **разворачивание**_

_**Замечание4**: в Java есть синтаксический сахар, который присутствует в строчках кода (*) и (**) без которого пришлось бы писать следующим образом:_
```Java
// ...
s.push(1); --> s.push(new Integer(1));
s.push(2); --> s.push(new Integer(2));
// ...  
int x = (Integer)(s.pop()).intValue();
```
### Основные проблемы при использовании необобщенных контейнерных классов
*Перепишем код предыдущей программы:*
```Java
Stack s = new Stack(); // попробуем засунуть double
// на этапе компиляции ошибки не будет
s.push(1);
s.push(2);
s.push(3.14); // опа постирония :)

int sum = 0;
while (!s.empty()) {
    int x = (Integer)s.pop();
    sum += x;
}

// Результат работы "java.lang.Double cannot be cast to java.langInteger"
```

_**Замечание**: Т.к. мы передаем 3.14 в контейнер, в котором числа по логике программы должны быть целые числа_

_**Замечание**: Мы не получаем никаких сообщений при компиляции, однако программа "свалилась" во время выполнения_

Решение приведенной проблемы - **использование обобщенных классов**.

### Понятие обобщенного класса

_Определение: **Обобщенный класс** - это класс, имеющий **формальные типовые параметры**._

_Определение: **Формальные типовые параметры** - это тип, который используется в объявлении обобщенного класса и при этом неизвестен во время компиляции обобщенного класса._

*Пример объявления обобщенного класса:*
```Java
class ClassName<param1, param2, ..., paramN>
```
*Пример:*
```Java
class Map<K, N>;
//параметры принято задавать в верхнем регистре
```
*Пример(Обобщенный класс `Stack`):*
```Java
import java.util.Arrays();

public class Stack<T> {
    private int count = 0;
    private Object[] buf = new Object[30];
    public boolean empty() { return count == 0; }
    public void push(T x) { // параметр обощаем, класс не зависим от него
        if (count == buf.lenght) {
            buf = Arrays.CopyOf(buf, buf.lenght * 2);
        }
        buf[count++] = x;
    }
    public T pop() {
        if (empty()) {
            throw new RuntimeExeption("emptySatck");
        }
        return (T)buf[--count];
    }
}
```
*Пример использования обобщенного класса `Stack`:*
```Java
// <Integer> - фактические типовые параметры //
Stack<Integer> s = new Stack<Integer>();
s.push(1);
s.push(2);
s.push(3);
int sum = 0;
while(!s.empty()) {
    int x = s.pop();
    sum += x;
}
```

< Integer > - фактические типовые параметры.

_**ВАЖНОЕ ЗАМЕЧАНИЕ**: При попытке добавить число 3.14 в Stack на этапе компиляции получим сообщение об ошибке._

```Java
"method push in class Stack<T> cannot be applied to given types"
```

_**Замечание:** Другим преимуществом класса `Stack` является то, что теперь метод `pop()` возвращает `Integer`, а не `Object`. При инициализации переменной `х` отпадает необходимость явного приведения типа._

### Ограниченные обобщенные классы

_ОПРЕДЕЛЕНИЕ: **Ограниченный обобщенный класс** - это обобщенный класс, хотя бы для одного формального типового параметра которого задана **верхняя граница**._

_УТВЕРЖДЕНИЕ: Говоря, что для формального типового параметра задана его верхняя граница, если базовый класс для типового параметра - НЕ `Object`._

Другими словами, такому типовому параметру разрешено сопоставлять не любой класс, а некоторый класс `X` или любого наследника `Х`.
```Java
class Имя<..., параметр extends X, ...>
```
_**ЗАМЕЧАНИЕ**: Задание верхней границы типового параметра класса `Х` позволяет вызывать методы класса `Х` из тела обобщенного класса.

*Пример:*
```Java
public class Stack<T extends Number> {
    private int count = 0;
    private Number[] buf = new Number[30];
    // ...
    // ... тут все методы empty() push() pop() без изменений (см. выше)
    // ...
    public T max() {
        if (empty()) {
            throw new RuntimeExeption("empty");
        }
        Number max = buf[0];
        for (int i = 1; i < count; i++) {
            Number x = buf[i];
            if (x.doubleVale() > max.doubleValue()) {
                max = x;
            }
        }
        return max;
    }
}
```

*Пример использования обобщенного ограниченного класса Stack:*
```Java
Stack<Integer> s = new Stack<Integer>();

s.push(1);
s.push(2);
s.push(3);
System.out.println(s.max());
```
_**Замечание:** В реализации класса Stack мы объявляем поле `buf` как массив `Number`ов, но компилятор проследит, чтобы фактические параметры (`T extends Number`) класса Stack выступали только наследники класса `Number`.

*Пример: Параметризуем класс Stack классом String :*
```Java
Stack<String> s = new Stack<String>();
//...
```
