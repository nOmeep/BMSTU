# Лекция №1. Понятие объекта и инкапсуляции
***
## Основные понятия

**Объект(`Object`)** - самоописывающая структура данных, обладающая внутренним состоянем, способная обрабатывать передаваемые ей сообщения.

**Инкапсуляция** - доступ к внутреннему состоянию объекта осуществляется извне (_через механизм передачи сообщений_).

**Класс(`class`)**: 
- тип данных, значениями которого являются объекты, имеющие сходные внутренние состояния и обрабатывающие одинаковый набор сообщений.
- шаблон объекта, обладающего какими-либо свойствами.

_Замечание: класс можно рассматривать как шаблон для порождения объектов -> объект - экземпляр класса._

## Классы в Java

**Классы в Java:**
- Публичные(`public`)
- Непубличные(например, `private`)

_Утверждение: любой java-файл должен содержать ровно 1 `public` класс, имя файла должно совпадать с именем класса!_

```Java
//Name.java:

    public class Name 
    {
        //... // описание класса, объявляются члены класса
    }
```

_Замечание: непубличные классы видны только в пределах этого файла(не `private` доступны также внутри пакета)!_

## Члены класса

- **Экземплярные поля:** для хранения внутреннего состояния объекта.
```Java
class Point
{
    double x; // поле x
    double y; // поле y
    //...
}
```
- **Экземплярные методы:** отвечают за обработку передаваемых объекту сообщений.
- **Статические поля:** хранение данных, общих для всех объетов класса.
- **Статические методы:** имеют доступ только к статическим полям, оперируют только с данными, общими для всех объектов класса.
- **Вложенные классы:** объекты, необходимые для реализации данного класса.
- **Статический конструктор:** набор `static` блоков, инициализация статических полей.

_Определение: **Статическое поле(static field)** - поле, разделяемое всеми объектами этого класса._

*Пример объявления статического поля:*
```Java
class Point 
{
    public int x, y; // координаты конкретной точки
    public static int count; // количество точек системы
}
```
_Определение: **Экземплярный метод** - подпрограмма, осуществляющая обработку переданного объекту сообщения. Экземплярный метод передает объекту сообщение._
- экземплярный метод имеет доступ к внутреннему состоянию объекта засчет передачи в экземплярном методе ссылки на сам объект. В Java эта ссылка имеет имя `this`.

_Определение: **Экземплярное поле** - именованная составляющая, составная часть внутреннего состояния объекта._

_Замечание: некоторые ООП ЯП допускают прямое обращение к экземплярным полям, что нарушает инкапсуляцию._

## Модификаторы доступа

*Пример использования модификаторов:*
```Java
class Person
{
    public String name;
    public int yearOfBirth;
    private String address; 
}
// private и public - модификаторы доступа
```
_Замечание: Модификаторы доступа предназначены для управления доступом к членам классов._

**Наименование модификатора:**
- `private`. Доступен самому себе
- `public`. Доступен всем и везде :-)
- `protected`. Доступен внутри пакета, самому себе и наследникам
-  *без модификатора*. Доступен внутри пакета

## Перегрузка методов

_Определение: **Сигнатура метода** - информация о количестве и формальных параметрах метода._

*Пример перегрузки метода:*
```Java
public class Cat 
{
    public String name;
    public int age;
    public int weight;
    public Cat(String name, int age, int weight)
    {
        this.name = name;
        this.age = age;
        this.weight = weight;
    }
    // перегружаем путем создания одноименного конструктора с другой сигнатурой
    public Cat() {
        //...
    }
}
```

_Определение: **Перегрузка метода(overload)** - объявление для одного и того же класса двух или более методов, имеющих одно и то же имя, но разные сигнатуры._
***
# Лекция №2. Статические поля, методы, блоки
***
потом допишу
***
# Лекция №3. Наследование и субтипизация. Переопределение методов.
***
потом допишу
***
# Лекция №4. Перегрузка. Абстрактные методы и интерфейсы.
***
потом допишу
***
# Лекция №5.
***
## Конейнерные классы

_Определение: **Контейнерный класс** - это класс, объекты которого выступают в роли хранилищ других объектов_

*Пример:*
- java.util.ArrayList
- java.util.Queue

_Замечание: контейнерные классы --> обобщенные классы(с java 15)_

*Пример необобщенного класса Stack:*
```Java
import java.util.Arrays;
public class Stack {
    // этот пример был ранее
    //...
}
```
*Использование необощенного класса Stack:*
```Java
//...
Stack s = new Stack();
s.push(1); // (*)
s.push(2); // (*)
s.push(3); // (*)
int sum = 0;
while(!s.empty()) {
    int x = (Integer)s.pop(); // Integer - обертка // (**) 
    s += x; // cумма элементов в стеке
}
//...
```
_**Замечание1**: "Обертки изучить самостоятельно" Посевин._

_**Замечание2**: Методичку с++ начать изучать самостоятельно, будет проверка :)_

_**Замечание3**: Метод `push()` требует `Object`, мы передаем целое число `int` в качестве параметра, в результате происходит автоматическое **заворачивание** целого числа (`int`) в объект стандартного класса `Integer`. Присвоение объекта класса `Integer` переменной `x` означает его автоматическое **разворачивание**_

_**Замечание4**: в Java есть синтаксический сахар, который присутствует в строчках кода (*) и (**) без которого пришлось бы писать следующим образом:_
```Java
// ...
s.push(1); --> s.push(new Integer(1));
s.push(2); --> s.push(new Integer(2));
// ...  
int x = (Integer)(s.pop()).intValue();
```
### Основные проблемы при использовании необобщенных контейнерных классов
*Перепишем код предыдущей программы:*
```Java
Stack s = new Stack(); // попробуем засунуть double
// на этапе компиляции ошибки не будет
s.push(1);
s.push(2);
s.push(3.14); // опа постирония :)

int sum = 0;
while (!s.empty()) {
    int x = (Integer)s.pop();
    sum += x;
}

// Результат работы "java.lang.Double cannot be cast to java.langInteger"
```

_**Замечание**: Т.к. мы передаем 3.14 в контейнер, в котором числа по логике программы должны быть целые числа_

_**Замечание**: Мы не получаем никаких сообщений при компиляции, однако программа "свалилась" во время выполнения_

Решение приведенной проблемы - **использование обобщенных классов**.

### Понятие обобщенного класса

_Определение: **Обобщенный класс** - это класс, имеющий **формальные типовые параметры**._

_Определение: **Формальные типовые параметры** - это тип, который используется в объявлении обобщенного класса и при этом неизвестен во время компиляции обобщенного класса._

*Пример объявления обобщенного класса:*
```Java
class ClassName<param1, param2, ..., paramN>
```
*Пример:*
```Java
class Map<K, N>;
//параметры принято задавать в верхнем регистре
```
*Пример(Обобщенный класс `Stack`):*
```Java
import java.util.Arrays();

public class Stack<T> {
    private int count = 0;
    private Object[] buf = new Object[30];
    public boolean empty() { return count == 0; }
    public void push(T x) { // параметр обощаем, класс не зависим от него
        if (count == buf.lenght) {
            buf = Arrays.CopyOf(buf, buf.lenght * 2);
        }
        buf[count++] = x;
    }
    public T pop() {
        if (empty()) {
            throw new RuntimeExeption("emptySatck");
        }
        return (T)buf[--count];
    }
}
```
*Пример использования обобщенного класса `Stack`:*
```Java
// <Integer> - фактические типовые параметры //
Stack<Integer> s = new Stack<Integer>();
s.push(1);
s.push(2);
s.push(3);
int sum = 0;
while(!s.empty()) {
    int x = s.pop();
    sum += x;
}
```

< Integer > - фактические типовые параметры.

_**ВАЖНОЕ ЗАМЕЧАНИЕ**: При попытке добавить число 3.14 в Stack на этапе компиляции получим сообщение об ошибке._

```Java
"method push in class Stack<T> cannot be applied to given types"
```

_**Замечание:** Другим преимуществом класса `Stack` является то, что теперь метод `pop()` возвращает `Integer`, а не `Object`. При инициализации переменной `х` отпадает необходимость явного приведения типа._

### Ограниченные обобщенные классы

_ОПРЕДЕЛЕНИЕ: **Ограниченный обобщенный класс** - это обобщенный класс, хотя бы для одного формального типового параметра которого задана **верхняя граница**._

_УТВЕРЖДЕНИЕ: Говоря, что для формального типового параметра задана его верхняя граница, если базовый класс для типового параметра - НЕ `Object`._

Другими словами, такому типовому параметру разрешено сопоставлять не любой класс, а некоторый класс `X` или любого наследника `Х`.
```Java
class Имя<..., параметр extends X, ...>
```
_**ЗАМЕЧАНИЕ**: Задание верхней границы типового параметра класса `Х` позволяет вызывать методы класса `Х` из тела обобщенного класса._

*Пример:*
```Java
public class Stack<T extends Number> {
    private int count = 0;
    private Number[] buf = new Number[30];
    // ...
    // ... тут все методы empty() push() pop() без изменений (см. выше)
    // ...
    public T max() {
        if (empty()) {
            throw new RuntimeExeption("empty");
        }
        Number max = buf[0];
        for (int i = 1; i < count; i++) {
            Number x = buf[i];
            if (x.doubleVale() > max.doubleValue()) {
                max = x;
            }
        }
        return max;
    }
}
```

*Пример использования обобщенного ограниченного класса Stack:*
```Java
Stack<Integer> s = new Stack<Integer>();

s.push(1);
s.push(2);
s.push(3);
System.out.println(s.max());
```
_**Замечание:** В реализации класса Stack мы объявляем поле `buf` как массив `Number`ов, но компилятор проследит, чтобы фактические параметры (`T extends Number`) класса Stack выступали только наследники класса `Number`.

*Пример: Параметризуем класс Stack классом String :*
```Java
Stack<String> s = new Stack<String>();
//...
```
***
# Лекция №6.
***
## Ковариантность массивов
_**Утверждение**: в Java массивы ковариантны. Если класс `S` является наследником класса `T`, то тип `S` является подтипом `T`._

В частности ковариантность массивов позволяет написать следующее:

```Java
Integer[] ints = new Integer[10];
Numbers[] numbers = ints;
```

*Пример:* что будет после попытки присвоить `numbers` ссылки на объект, тип которого не `Integer`:
```Java 
numbers [0] = 3.14;
```
*Результат:(при компиляции ошибки не произойдет в силу ковариантности, но во время исполнения программа аварийно завершится с исключением)*
```Java
"java.lang.ArrayStoreExeption"
```
*Утверждение: Если бы удалось положить ссылку `Double` в `numbers`, то эта ссылка бы очутилась в массиве `int`, в котором должны храниться только ссылки на `Integer`.*

## Инвариантность обобщенных классов 

*Пример: с классом `Stack` в обобщенном варианте*
```Java
Stack<Integer> ints = new Stack<Integer>();
Stack<Numbers> = ints
// выше делали похожую операцию 
// ошибка возникнет на этапе компиляции, а не на этапе исполнения
```
*Результат:*
```Java
error: incompatible types
Stack<Number> numbers = ints;
                        ^
```
*Комментарий:*
- Это происходит, потому что обобщенные классы в Java **инвариантны**!

Т.е. если `G` - обобщенный класс, класс `S` - наследник класса `T`, то классы `G<S>` и `G<T>` отношением наследования не связаны.

*Комментарий:*
- Если обобщенный класс `DerivedStack<T>` - наследник `Stack<T>`, то `DerivedStack<Integer>` - наследник `Stack<Integer>`

## Шаблоны обобщенных классов 

_**Замечание:** Инваринатность обобщенных классов, на первый взгляд, ограничивает возможность полиморфной обработки объектов этих классов. Например, наивно написанный метод для вывода содержимого стека `Number`'ов будет непригоден для вывода стеков `Integer`'ов_
```Java
public static void printStack(Stack<Number> stack) {
    while (!stack.empty()) {
        Number x = stack.pop();
        System.out.println(x);
    }
}
```
Указанный выше метод непригоден для `Integer`. Для обхода подобного будем делать следующее.

**Определение:** Шаблон обобщенного класса `G` - это неявный супертип(более глобальный тип данных) для любого класса, поражденного из `G`. Шаблон получается параметризацией класса `G` специальным символом `?`. Например `Stack<?>`.

## Особеенности шаблонов 

1. **Можно** объявлять переменную типа "шаблон", но **невозможно** создать его объект.

    *Пример:*
    ```Java
    // Так можно
    Stack<?> x; // correct

    // Так нельзя
    x = new Stack<?> // error fuck u leatherman
    ```
    _**Замечание:** В данном случае мы над переменной понимаем не только локальные переменные, но и формальные параметры методов, поля, элементы массивов._

    *Пример: массив с элементами типа "шаблон"*
    ```Java
    Stack<?>[] a = new Stack<?>[10];
    ```

2. Если тип переменной - шаблон некоторого обобщенного класса `G`, то этой переменной можно присвоить ссылку на любой объект класса `G`, независимо от того, какой фактический типовой параметр был передан классу `G` при создании объекта.

    ```Java
    x = new Stack<Integer>;
    x = new Stack<Float>;
    ```
    *Пример:* полимофизм на основе шаблонов.
    ```Java
    public class Test {
        public static void printStack(Stack<?> stack) {// теперь используем обобщенный шаблон, раньше был Numbers, а стал "?"
            while (!stack.empty()) {
                Number x = stack.pop();
                System.out.println(x);
            }
        }
    }
    ```

    ```Java
    public static void main(String[] args) {
        Stack<Integer> s = new Stack<Integer>();
        s.push(1);
        s.push(2);
        s.push(3);
        printStack(s);
    }
    ```
    _**Замечание**: Метод pop шаблона `Stack<?>` возвращает Number - верхняя граница формального типового параметра обобщенного класса `Stack` (см. предыдущую лекцию)_

## Частичные шаблоны 

_**Утверждение:** Если обобщенный класс имеет несколько формальных типовых параметров, то возможно получить **частичный шаблон**, передав классу `?` вместо части фактических типовых параметров_

```Java
Map<Integer, ?> intMap;
// Правильно 
intMap = new Map<Integer, String>(); // correct

// Это тоже пойдет
intMap = new Map<Integer, Float>(); // corret

// А за такое suck some dick
intMap = new Map<Double, String>(); // ERROR!
```

Последнее присваивание вызовет ошибку компиляции, потому что первый фактический параметр обобщенного класса `Map` не `?` и даже не `Double`, а `Integer`!

## Шаблоны, ограниченные сверху
Как было показано в примере о методе `pop()` шаблон `Stack<?>`, фактический параметр `?` имеет верхнюю границу, по умолчанию совпадает с верхней границей соответвующего формального параметра обобщенного класса.

*Пример*: Верхней границей `?` в `Stack<?>` является `Number`, поэтому `pop()` для `Stack<?>` возвращает `Number`.

_**Замечание**: Верхнюю границу в шаблоне `?` можно уточнить так:_
```Java
G<..., ? extends X, ...>
```
_**Замечание**: Уточнение верхней границы сузит количество подтипов шаблона:_
```Java
Stack<Float> floats = new Stack<Float>();
Stack<?> numbers = floats;
Stack<? extends Integer> ints = floats; // ERROR! 
```


