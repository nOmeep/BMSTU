Конспект по JavaScript
=============================

	1. Типизация и системы типов
	----------------------------:
			
		* Undefined (Неопределенный тип)  : typeof instance === "undefined" :
			 Переменная, которой не было присвоено значение, будет иметь значение undefined
		
		* Boolean (Булев, Логический тип) : typeof instance === "boolean" :
			 Булевый тип представляет логическую сущность и имеет два значения: 
			 true (истина) и false (ложь)
		
		* Number (Число) : typeof instance === "number" :
			 Cуществует только один числовой тип, который представляет собой 64-битное число двойной точности. 
			 Другими словами, специального типа для целых чисел в JavaScript нет. 
			 Это означает, что при числовых операциях вы можете получить округлённое(неточное) значение.
		
		* String (Строка) : typeof instance === "string" :
			 Он представляет собой цепочку «элементов» 16-битных беззнаковых целочисленных значений. 
			 Каждый такой элемент занимает свою позицию в строке. Первый элемент имеет индекс 0, следующий — 1, и т.д. 
			 Длина строки — это количество элементов в ней.
			 ** Получить часть исходной строки выборкой отдельных символов, либо применением метода String.substr() **
			 ** Можно объединить две строки в одну, применив оператор (+) **
		
		* BigInt  : typeof instance === "bigint" :
			 Является встроенным объектом, который предоставляет способ представления целых чисел, 
			 которые больше 2 53, что является наибольшим числом, 
			 которое JavaScript может надежно представить с помощью Number примитива
		
		* Symbol (в ECMAScript 6)  : typeof instance === "symbol"
		
		* Null (Null тип ) : typeof instance === "object" :
			 Специальный примитив, используемый не только для данных, 
			 но и в качестве указателя на финальную точку. 
			 Этот тип данных имеет всего одно значение: null.
		
		* Object (Объект) : typeof instance === "object". 
			 Простая структура, используемая не только для хранения данных, 
			 но и для создания других структур, где любая структура создаётся 
			 с использованием ключевого слова new.
		
		* Function : typeof instance === "function" : 
			 Специальный случай, упрощающий определение типа для Функций, 
			 несмотря на то, что все функции конструктивно унаследованы от Object.

@
	var foo = 42; // сейчас foo типа Number
	foo = "bar"; // а теперь foo типа String
	foo = true;  // foo становится типа Boolean
@
	
	2.Основные управляющие конструкции
	----------------------------------:
		
		Условные операторы JavaScript
		#############################:
		
			* Условный оператор if :
				 Инструкция if(...) вычисляет условие в скобках и, если результат true, то выполняет блок кода
				 Синтаксис:
			 		if (условие) { // в случае истинности условия выполняются действия в следующем блоке, иначе выполняются действия в блоке else
		 				действие1
	 					...
 					} 
			 		else { // else является необязательным компонетнтом
			 			действие1
			 			...
		 			}
	 		
			* Тернарный оператор "?" :
	 			Является более лаконичной версией условного оператора if
	 			Синтаксис:
	 				(условие) ? (если условие истинно) : (если условие ложно) 
			
			* Оператор switch :
	 			Конструкция switch заменяет собой сразу несколько if. 
	 			Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.
				Синтаксис:
	 				Switch (выражение)
	 				{
				 		case L1: 
				 			оператора1; 
							break; // break является обязательной частью каждого case, иначе выполнение будет просачиваться в следующие case'ы. Break можно использовать для экстренного выходя из циклов, о которых чуть ниже.
		 				case L2: 
		 					оператор2; 
		 					break;
		 				...
		 				case Ln: 
		 					операторN; 
		 					break;	
		 				default: операторDefault //может отсутствовать
		 			}
	
		Циклические операторы JavaScript
		################################:
			
			* Цикл "while" :
				 Нужен для многократного повторения одного участка кода предусмотрены циклы.
			         Код из тела цикла выполняется, пока условие condition истинно.
			        ** для пропуска какой-то части цикла и перехода на новую итеацию можно воспользоваться оператором continue **
				Синтаксис:
				 	while (condition) {
  						// код
  						// также называемый "телом цикла"
				 	}
				
				* Цикл "do...while" :
				 	Тот же самый while, но с проверкой словия не в начале, а после выполнения тела
				 	для пропуска какой-то части цикла и перехода на новую итеацию можно воспользоваться оператором continue.
					Синтаксис:
				 		do {
				 			//body
				 		}
				 		while (condition);
				
				* Цикл "for" :	
					Синтаксис:
				 		for (начало; условие; шаг) {
				 			//body_for
				 		}
				 	** часть "начало" выполняется один раз перед входом в цикл
				   	часть "условие" проверяет на истинность условие, записанное здесь
				   	часть "шаг" - то, что выполняется после каждой итерации **
				 	** для пропуска какой-то части цикла и перехода на новую итеацию можно воспользоваться оператором continue **
				
	3. Подмножество языка для функционального программирования
	-----------------------------------------------------------:
	
		Иммутабельность JavaScript
		##########################:
			
		 	Иммутабельным называется объект, состояние которого не может быть изменено после создания.
		 	Результатом любой модификации такого объекта всегда будет новый объект, при этом старый объект не изменится. 
			
			* Ключевое слово const в JavaScript :
		 		Использование const вместо var или let не говорит от том, что значение является константой или что оно иммутабельно (неизменяемо). 
		 		Ключевое слово const просто указывает компилятору следить за тем, что переменной больше не будет присвоено никаких других значений.
				
			* Object.freeze в JavaScript :
		 		Метод Object.freeze замораживает объект. 
		 		Это значит, что он предотвращает добавление новых свойств к объекту, удаление старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемости и записываемости. 
		 		В сущности, объект становится эффективно неизменным. Метод возвращает замороженный объект.
			
			Библиотеки
			%%%%%%%%%%%:
				
				* Seamless-Immutable :
		 			Библиотека предлагает иммутабельные структуры данных, обратно совместимые с обычными массивами и объектами. 
		 			То есть доступ к значениям по ключу или по индексу не будет отличаться от привычного, 
		 			будут работать стандартные циклы, а также все это можно использовать в связке со 
		 			специализированными высокопроизводительными библиотеками для манипуляций с данными, вроде Lodash или Underscore.
		
			
		Функции как объекты 1-го класса JavaScript
		##########################################:
			
		 	В JavaScript функции являются объектами первого класса, поскольку они могут иметь свойства и методы, как и любой другой объект.
		 	Их отличает от других объектов то, что функции могут быть вызваны. 
		 	Другими словами, они являются функциональными объектами.
		
		Функции высших порядков и встроенные функции высших порядков JavaScript
		#######################################################################:
		
		 	Функции, которые принимают в качестве параметра функции и могут возвращать функции как результат выполнения, 
		 	называются функциями высшего порядка. Такие функции широко используются в JavaScript.
			
 			Пример: Array.prototype.map, Array.prototype.filter и Array.prototype.reduce

// программа с использованием функций высшего порядка JavaScript		
@
	// вывод нового массива с числами, помноженными на 2
	const arr1 = [1, 2, 3];
	const arr2 = arr1.map(function(item) {
  		return item * 2;
	});
	console.log(arr2);
@		

	
	4. Важнейшие функции для работы с потоками ввода/вывода, строками, регулярными выражениями.
	-------------------------------------------------------------------------------------------:
	
		Поток вывода
		############:
			
			* Console.log() стандартный поток вывода:
			 	Выводит сообщение в консоль(веб-консоль, если в браузере)
				Синтаксис:
			 		console.log(obj1 [, obj2, ..., objN]);
			 		console.log(msg [, subst1, ..., substN]);
@

	var text = "this is text";
	console.log(text);
	// >> this is text
@	
			
			* Console.error() стандартный поток вывода ошибок:
			 	Выводит сообщение об ошибке в консоль(веб-консоль, если в браузере)
				Синтаксис:
			 		console.error(obj1 [, obj2, ..., objN]);
			 		console.error(msg [, subst1, ..., substN]);
			 		console.exception(obj1 [, obj2, ..., objN]);
			 		console.exception(msg [, subst1, ..., substN]);
@
	console.error("You made a mistake"); 
	//выведет на экран соощение об ошибке >> You made a mistake
@
		Поток ввода
		###########:
			
	 		Модуль readline предоставляет интерфейс для чтения данных из открытого для чтения данных
	 		из открытого для чтения стрима(как process.stdin) по одной строке за раз. 
	 		К нему можно получить доступ так:
@
	const readline = require('readline');

	const rl = readline.createInterface({
  		input: process.stdin,
  		output: process.stdout
	});

	rl.question('Как вы относитесь к основам информатики', (answer) => {
  		// TODO: Log the answer in a database
  		console.log(`Спасибо за ответ: ${answer}`);

  	rl.close();
});
@

		Работа со строками
		##################:
		
	 		String — это объектная реализация примитивного строкового значения. 
	 		Его конструктор имеет вид:
@
	new String(значение?)
@
			Свойство length :
		 		Дает возможность узнать количество символов в строке.
				@
					объект.length 
				@
				
			
			Метод anchor :
		 		Возвращает строку, состоящую из примитивного значения строкового объекта,
		 		заключенного в теги <A NAME="имя">…</A>. 
		 		Проверки на то, не была ли исходная строка уже заключена в эти теги, 
		 		не делается. 
		 		@
		 			объект.anchor
		 		@
				
			Метод big :
		 		Метод big возвращает строку, состоящую из примитивного значения строкового
		 		объекта, заключенного в теги <BIG>…</BIG>.
		 		@
		 			document.write("Мой текст".big())
		 		@
			Метод indexOf :
		 		Возвращает позицию первого вхождения заданной подстроки 
		 		(lastIndexOf делает наоборот)
		 		@
				 	"Привет, мир".indexOf("Привет")
				 	// вернет 0
		 		@		 
			Метод concat :
		 		Возвращает конкатенацию строк. Конкатенировать строки можно также и с помощью "+"
		 		@
		 			var alpha = ["a", "b", "c"];
		 			var numeric = [1, 2, 3];
		 			// создает массив ["a", "b", "c", 1, 2, 3];
		 			var alphaNumeric = alpha.concat(numeric);
		 		@
				
		Регулярные выражения
		####################:
			
		 	В JavaScript регулярное выражение — это один из типов объектов, 
		 	который используется для поиска комбинаций символов в строках.
		 	Существует два способа создания регулярных выражений.
		 	Первый заключается в использовании литералов регулярных выражений. 
		 	При таком подходе шаблон регулярного выражения заключают в слэши. Выглядит это так:
	 		@
		 		var regexLiteral = /cat/;
		 	@
	 		Второй задействует конструктор объекта RegExp, которому передают строку, 
	 		из которой он создаёт регулярное выражение:
	 		@
	 			var regexConstructor = new RegExp("cat");
	 		@
			
			Методы регулярных выражений
			%%%%%%%%%%%%%%%%%%%%%%%%%%%:
				
				Метод .test() :
	 				Возвращает true если строка содержит совпадение с заданным шаблоном
	 				регулярного выражения. Если совпадений не найдено — 
	 				он возвращает false.
					@
	 					const str1 = "the cat says meow";
	 					const str2 = "the dog says bark";	
	 					const hasCat = /cat/;
	 					hasCat.test(str1);	
	 					// true
	 					hasCat.test(str2);
	 					// false
					@
			Базовые кнострукции регулярных выражений
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%:
				
				Символы:
				
			 		* . (точка) — соответствует любому одиночному символу за исключением переноса строки.	
		
			 		* * — соответствует предыдущему выражению, которое повторено 0 или более раз.
		
			 		* + — соответствует предыдущему выражению, которое повторено 1 или более раз.
		
			 		* ? — соответствует предыдущему выражению, повторённому 0 или 1 раз.
				
			 		* ^ — соответствует началу строки.
					
			 		* $ — соответствует концу строки.
				
				Группы символов:
				
			 		* \d — соответствует любому одиночному цифровому символу.
			 		
			 		* \w — соответствует любому символу — цифре, букве, или знаку подчёркивания.
			 		
			 		* [XYZ] — набор символов. Соответствует любому одиночному символу из набора, заданного в скобках. 
			 		Кроме того, похожим образом можно задавать и диапазоны символов, например — [A-Z]
			 		
			 		* [XYZ]+ — соответствует символу из скобок, повторённому один или более раз.
			 		
			 		* [^A-Z] — внутри выражений, задающих диапазоны символов, символ ^ используется как знак отрицания. 
			 		В данном примере шаблону соответствует всё, что не является буквами в верхнем регистре
				
				Флаги:
					
			 		Существует пять необязательных флагов регулярных выражений. 
			 		Они могут использоваться совместно или раздельно, их помещают после закрывающего слэша. 
			 		Регулярные выражения с флагами выглядят так: /[A-Z]/g.
					
			 		* g — глобальный поиск по строке.
					
			 		* i — поиск, нечувствительный к регистру.
			 		
			Функции для работы с регулярными выражениями
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%:
				
			 	Конструктор RegExp создаёт объект регулярного выражения для сопоставления текста с шаблоном.
				Cинтаксис:
			 		/pattern/flags 
			 		new RegExp(pattern, flags)
			 		//pattern - текст регуярного выражения
				
				
				
		
				
		

		
		
		
		
			
